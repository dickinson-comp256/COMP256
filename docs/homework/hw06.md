## Homework #06

#### Branching and Looping

Give an assembly language implementation that is equivalent to each of the following high level language programs.  Assemble and run your programs on our machine to ensure that they work.

   1. A program that rounds an integer up to the next closest even integer.
      ```
      int x;
      Read x;
      if (x % 2 != 0) {  // if x is odd.
         x++;
      }
      Print x;
      ```

   1. A program that computes the whole number part of the log base 2 of an integer.  The log base 2 of a number is the number of times that it can be divided by 2 before reaching the value 1.  One way to do this is to use integer division and count how many times the number can be divided by 2 before getting a result that is less than or equal to 1.  Hint: The `SHR` operation should help you here.
      ```
      int a;
      int log = 0;

      Read a;
      while (a > 1) {
        log++;
        a = a / 2;   // Integer division by 2.
      }

      Print log;
      ```

   1. A program that reads a specified number of positive integers from standard input and prints out the largest value read.
      ```
      int n;
      int max = 0;

      Read n;
      for (int i=0; i<n; i++) {
         Read j;
         if (j > max) {
             max = j;
         }
      }
      Print max;
      ```

   1. A program that computes the sign function of a provided value:

      ![Sign function](hw06-signum.jpeg)

      ```
      int x;

      Read x;

      if (x < 0) {
         Print -1;
      }
      else if (x == 0) {
         Print 0;  
      }
      else {
         Print 1
      }
      ```

#### Arrays and Indirect Addressing

1. Consider the following HLL program statements that allocate arrays:
   ```
   int p[] = new int[50];
   int q[] = {10, 20, 30, 50, 60};
   ```
   1. Give assembly language statements that will allocate these arrays and the references to them.
   1. Give assembly language instructions that will set the values of the references to the arrays.
   1. Assuming the symbol table below, draw a picture of the physical array implementation in memory (use the pictures in the slides as an example).
      ```
      Symbol      Address
      --------------------
      P           150
      PARR        400
      Q           154
      QARR        200
      ```

1. Consider the following assembly language code that creates an array and the reference to it.  Assume also that the assembler has used the given symbol table.
   ```
   T:      .word                        Symbol      Address
   TARR:   .word 1 9 3 2 5 4            --------------------
                                        T           350
           LOAD R0 #TARR                TARR        354
           STORE R0 T
   ```
   1. For each of the following assembly language instructions, indicate the addressing mode that it is using and give the value that will be loaded into `R1`:
      1. `LOAD R1 #5`
      1. `LOAD R1 T`
      1. `LOAD R1 #T`
      1. `LOAD R1 TARR`
      1. `LOAD R1 #TARR`
      1. `LOAD R1 R0`
      1. `LOAD R1 R0 +16`
      1. `LOAD R1 R0 +2`

   1. Give assembly language instructions that implement each of the following high level language operations on the array `t`.
      1. `T[0] = 10`
      1. `T[5] = T[1]`
      1. `T[1] = T[T[3]]`
      1. Swap the values in `T[0]` and `T[5]`

1. Consider the following assembly language code that creates an array and the reference to it.
   ```
   M:      .word
   MARR:   .word 10 20 30 40 50 60 70

           LOAD R0 #TARR
           STORE R0 T
   ```
   1. Give the values that will be stored in `R5`, `R6`, `R7` and `R8` after the following instructions would execute:
      ```
      ADD R0 R0 #4
      LOAD R5 R0
      ADD R0 R0 #4
      LOAD R6 R0
      ADD R0 R0 #4
      LOAD R7 R0
      ADD R0 R0 #4
      LOAD R8 R0
      ```

   1. The answer to the previous question should give some insight into how you could use a loop to go through the elements of an array. Above `R0` initially held the address of the first element of the array (i.e. `M[0]`). Register indirect addressing mode was then used to set `R5 = M[0]`.  When `4` was added to `R0` it then held the address of the second element of the array (i.e. `M[1]`).  Similarly, each time `4` was added to `R0` the address became that of the next element in the array.  This idea can be adapted for use in a loop to go through all of the elements in an array by adding `4` to the address being used each time.

      Write an assembly language program that uses a loop to add 1 to each of the values in the array `M`.  Assemble and run your program to be sure that it works. When you run the program, you will find the values in the array in the memory just after the `HALT` instruction (All `1`s).

1. Write an assembly program that computes the first 20 Fibonacci numbers. In a high level language this program might be something like:
   ```
   int[] fib = new int[30];

   fib[0] = 1
   fib[1] = 1

   for (int i=2; i < 20; i++) {
      fib[i] = fib[i-1] + fib[i-2];
   }
   ```

   Assemble and run your program on our machine to ensure that it works.  When you run the program, you will find the array of Fibonacci numbers in the memory just after the `HALT` instruction.

<!--
1. You may have noticed that although all of our array programs create a reference to the array, as is done in Java, we haven't actually needed them.  So a logical question would be why bother?  

   Consider the following HLL program:
   ```
   int[] x = {1, 2, 3, 4, 5};
   int[] y = {2, 4, 6, 8, 10};
   int a;

   Read a;

   if (a > 0)
      x = y;

   Print x[1];
   ```

   It is impossible to know if this program will print `2` or `4` until after it is run.  Thus,
-->

#### Functions and Parameters

1. Consider the following program statements:
   ```
   .stacksize 100

   PUSH R0
   PUSH R3
   POP R0
   PUSH R2
   PUSH R1
   POP R2
   POP R1
   ```

   Now assume that the following registers have the given initial values:
   ```
   R0:    10
   R1:    20
   R2:    30
   R3:    40
   R13: 1000
   ```

   Give the contents of the registers and draw a picture of the stack and its contents after the above program statements have executed.

1. Consider the following HLL program:
   ```
   main() {                       int DoubleIt(int x) {
     read a;                        y = x + x;
     twoA = DoubleIt(a);            return y;
     print twoA                   }
   }
   ```

   1. Give an assembly language implementation of `main`. When writing the `main` function you will need to write all of the pieces of the calling code (push the arguments, call the function, get and use the return value). Use the `main` code from the `max` example in the slides as a guide.  Note that in the `max` example there were two parameters, here there is only one.

   1. Give an assembly language implementation of the `DoubleIt` function.  When writing `doubleIt` you will need to include all of the appropriate pieces of the called code (push the return address, push modified registers, get the arguments, implement the computation, set the return value restore registers and return address and clean up the stack.) Here, use the `max` code from the `max` example in the slides as a guide.

   If you combine your code from the previous question with your answer to this question, you should be able to assemble and run your program.  I highly recommend this exercise as it will force you to deal with any misunderstandings you might have.

1. Write assembly code that implements the `max3` function from the class slides.  Assume that you have the assembly code for `max` as given in the slides.  Thus, your implementation of `max3` should contain two calls to `max`.  

1. Write an assembly program that reads in 3 values, calls `max3` and displays the result.

   If you combine your code from the previous question with your answer to this question and the `max` implementation from the slides, you should be able to assemble and run your program.  I highly recommend this exercise as it will force you to deal with any misunderstandings you might have.

1. Consider the following code that calls the `max` function from the class slides:
   ```
          .stacksize 100

          LOAD R1 #100
          LOAD R2 #20
          PUSH R2
          LOAD R3 #10
          PUSH R3
          CALL MAX
          STORE R1 STDOUT
          STORE R2 STDOUT
          STORE R4 STDOUT
   ```

   1. What output would be generated when this code is run?

   1. Now consider the following implementation of the `max` function that contains a common error:
      ```
      MAX:   PUSH R12          * + 4

             LOAD R2 R13 +8    * R2 is b
             LOAD R1 R13 +12   * R1 is a

             MOV R3 R1         * R3 is x = a
             BGEQ R1 R2 SKIP   * a >= b
             MOV R3 R2         * x = b

      SKIP:  MOV R14 R3        * RV = x

             POP R12
             ADD R13 R13 #8

             RET
       ```

       1. Given the above implementation of `max` what output would be generated by the code in part 1?

       1. What did the programmer omit (forget?) in this implementation of `max`?

       1. Explain why the omitted code is important to viewing function calls as an abstraction.

1. Consider the assembly program below.
   ```
          .stacksize 100

          LOAD R0 #0
          STORE R0 STDOUT
          CALL ONE
          STORE R0 STDOUT
          HALT

   ONE:   LOAD R1 #1
          STORE R1 STDOUT
          CALL TWO
          STORE R1 STDOUT
          RET

   TWO:   LOAD R2 #2
          STORE R2 STDOUT
          RET
   ```
   1. At first glance it appears that it might work fine, outputting `0 1 2 1 0`. However, it does not.  What output does this program generate?

   1. What must be done in function `ONE` to cause program to output `0 1 2 1 0`?  Why is that necessary?
