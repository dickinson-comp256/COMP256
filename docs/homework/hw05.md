## Homework #05

#### Memory Hierarchy and Parallelism

1. We talked about the different types of memory in a modern machine (registers, cache, ram, SSD, HDD, etc...).  We discussed how there was a tradeoff between cost and speed. The speed of the different types of memories is typically reported as their _access time_ (a.k.a. _transfer time_). That is, the time it takes to transfer an instruction or piece of data from that memory to a register on the CPU. We also discussed how the cost of these memories is inversely related to their speed (faster memories are more expensive). Do some research about the _memory hierarchy_ on-line and fill in the following table with relatively current values.  All costs should be for the same units (byte, KB, MB or GB), and be sure to indicate the units that you are reporting on.

   ```
   Memory Type       Access Time       Cost/Unit
   ------------------------------------------------
   CPU Register
   Cache Memory
   Main Memory
   SSD
   HDD
   ```

1. Explain in a few sentences how the values in your table from the prior question confirm the inverse relationship between access time and cost that exists in the memory hierarchy.

1. In class we used a "Chef in the Kitchen" analogy to understand cache  conceptually.  Give another real-world example of how cache is used to improve the access time to things we use.  Be sure to clearly identify the things in your example that are analogous to the main memory, the cache and the registers.

1. Consider the following snippet of code:  
   ```java
   int x[] = new int[1000];
   x[0] = 1;
   x[1] = 1;
   for (int i=2; i<x.length; i++) {
       x[i] = x[i-1] + x[i-2];
   }
   ```
   1. What does this code do?
   1. The effectiveness of cache memory relies on the two locality principles: _Spatial Locality_ and _Temporal Locality_.  Thus, cache memory would only improve performance if programs exhibit these properties.  This question looks at a typical piece of code and asks how it exhibits them.  
      1. Explain in a few sentences several ways that this program exhibits spatial locality.
      1. Explain in a few sentences several ways that this program exhibits temporal locality.

1. Consider the a system with the following properties.  A 16 GB main memory with an access time of 50 nanoseconds, a 128 KB cache with access time of 1 nanosecond and a cache hit rate of 96% (i.e. 96% of memory requests result in cache hits).

   1. Using your values from the first question above:
      1. How much would the main memory for this system cost?
      1. How much would the cache memory for this system cost?
      1. How much would the main memory cost if it were built from the same technology as the cache?

   1. The average access time required to retrieve a value from memory in a system is called the _effective access time (EAT)_.  The addition of a cache to a system should reduce its EAT.  This is because any requests that result in a _cache hit_ are processed by the cache, which is faster than main memory. While requests that result in a _cache miss_ are processed by the main memory. Thus, the more cache hits the lower the EAT will be.  

      1. Use a weighted average to find the EAT for this system.
      1. What would the EAT be for this system if instead of using cache the entire main memory were made using the same technology as the cache?

   1. Using your above answers briefly justify why cache memory presents an effective cost/performance tradeoff.

1. Optional Challenge: Recall the following two snippets of code from the first day of class.  They look very similar, but yet the second one (`failure4b`) took far longer to run.  Explain why this is the case.
   ```java
   public static void failure4a() {
       int[][] x = new int[100000][10000];
       long start = System.nanoTime();
       for (int i = 0; i < x.length; i++) {
         for (int j = 0; j < x[0].length; j++) {
           x[i][j] = 1;
         }
       }
       long end = System.nanoTime();
       System.out.println("Time: " + (end - start)/1e9 + " seconds");
     }

     public static void failure4b() {
       int[][] x = new int[100000][10000];
       long start = System.nanoTime();
       for (int i = 0; i < x[0].length; i++) {
         for (int j = 0; j < x.length; j++) {
           x[j][i] = 1;
         }
       }
       long end = System.nanoTime();
       System.out.println("Time: " + (end - start)/1e9 + " seconds");
     }
     ```

#### Parallelism (wrap up) then Language Abstractions

1. Consider the following small Knob & Switch machine language program.
   ```
   MM  Instruction/Data          Effect
   -------------------------------------------
   0:  R0 = MM[10]
   1:  R1 = MM[11]
   2:  R2 = R0 - R1
   3:  if zero PC = 5
   4:  MM[10] = R2
   5:  HALT

   R0 = R0 + R0
   MM[11] = R0

   ```
   Now imagine that the Knob & Switch is improved to have a pipelined Fetch/Decode/Execute cycle. With this improvement the above program contains several resource hazards and a control hazard.

   1. Indicate two instructions that are involved in a resource hazard and explain why they create that hazard.
   1. Indicate two instructions that are involved in a control hazard and explain why they create that hazard.

1. For each of the following, indicate if it is source code, byte-code or executable code.
   1. A BASIC program
   1. A BASIC interpreter
   1. A Java program
   1. A compiled Java program
   1. A Java Compiler
   1. A Java Virtual Machine
   1. A C++ Program
   1. A C++ Compiler
   1. A compiled C++ program

1. For each of the following, indicate if it is platform dependent or platform independent.
   1. A C program
   1. A C Compiler
   1. A compiled C program
   1. A Python program
   1. A Python Virtual Machine
   1. A Javascript program
   1. A Javascript interpreter

1. For each of the following situations, indicate if a compiled language or an interpreted language would be more appropriate:
   1. The auto-pilot program for an airplane.
   1. A small utility program that will be used by people with lots of different types of computers.
   1. A program that the end users should be able to easily change to suit their specific situation.
   1. A program that users should not be able to modify.
   1. A program to perform complex calculations on a high performance super-computer.

1. As discussed, some languages like Java, Python and C# are compiled to byte-code which is then interpreted by a virtual machine. Explain how these languages achieve have some of the advantages of both compiled and interpreted languages.

#### Assembly Language Programs  

1. Coming Soon

<!--
1. What does the following assembly language program do:
```
LOAD R0 X
NOT R0 R0
ADD R0 R0 1
STORE R0 X
```

1. Experiment with the SHR and SHL commands and describe what they do in terms of the bits of the number and the value of the number.

1. Write assembly lanuage programs the perform each of the tasks below.  You should assemble and test your programs using the Assembler and the Machine.
   1. Simple computation

   1. Do 5-X with X from keyboard
-->
